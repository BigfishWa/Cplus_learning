# new和delete

### 1、new和delete是如何实现的，new 与 malloc的异同处？

- 在new一个对象的时候，**首先会调用malloc为对象分配内存空间，然后调用对象的构造函数**（这其实也是区别）。delete会调用对象的析构函数，然后调用free回收内存。
- new与malloc都会分配空间，但是new还会调用对象的构造函数进行初始化，malloc需要给定空间大小，而new只需要对象名。



### 2、既然有了malloc/free，C++中为什么还需要new/delete呢？

详见：https://blog.csdn.net/leikun153/article/details/80612130

- malloc/free和new/delete都是用来申请内存和回收内存的。
- 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而**malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free。**



### 3、内部数据类型和非内部数据类型

- 内部数据类型是编译器本身就认识的，不需要用户自己定义。如：基本数据类型：**int，char，double**等都是内部数据类型；
- 非内部数据类型不是编译器本身就认识的，需要用户自己定义才能让编译器识别。如：由**class，struct，union**等关键字修饰 的变量都是非内部数据类型。



### 4、new和new[]

对对象进行内存分配时，有一下两种方式：

```c++
//使用new，系统动态分配自动计算所需大小
int* p;
p = new int;
*p = 5;


//使用手动分配，sizeof计算
int* pn;
int i = 5 ;
pn = new int[i*20];
pn[0] = 20 ;
pn[100] = 30;
```



### 5、delete和delete[]（内存泄露）

释放空间的话，也会不一样。

- delete只会调用一次析构函数，而**delete[]会调用每个成员的析构函数**
- 用new分配的内存用delete释放，用new[]分配的内存用delete[]释放

如果使用new，那么可以使用delete和delete[];而使用new[]，那么只能使用delete[].

这是因为如果动态分配了一个数组，但是却用`delete p`的方式释放，没有用`[]`，则编译时没有问题，运行时也一般不会发生错误，但实际上会导致动态分配的数组没有被完全释放。



**内存泄漏**：

牢记，用 new 运算符动态分配的内存空间，一定要用 delete 运算符释放。**否则，即便程序运行结束，这部分内存空间仍然不会被操作系统收回，从而成为被白白浪费掉的内存垃圾。这种现象也称为“内存泄露”**。

如果一个程序不停地进行动态内存分配而总是没有释放，那么可用内存就会被该程序大量消耗，即便该程序结束也不能恢复。这就会导致操作系统运行速度变慢，甚至无法再启动新的程序。**但是，只要重新启动计算机，这种情况就会消失**。

**编程时如果进行了动态内存分配，那么一定要确保其后的每一条执行路径都能释放它。**

另外还要注意，释放一个指针，并不会使该指针的值变为 NULL。见6，delete的本质。



### 6、delete的本质

C++标准规定：delete空指针是合法的，没有副作用。

**对一个非空指针delete后，若没有赋NULL，若再次delete的话有可能出现问题。如下代码：**

```c++
int* p = new int;
*p = 5;
delete p;
p=nullptr;
delete p;  //如果上面p=nullptr;被注释的话，本句会导致程序出错
```



可以看出，**delete是释放指针指向的内存，并不是指针本身所占有的内存。**所以delete后，指针的还是指向那块区域，并

未清0，所以如果下次用到，就会发生xxx空间不能访问的异常，**所以，delete后要赋值为空或0是个好习惯。**


