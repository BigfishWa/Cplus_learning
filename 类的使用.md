参考文档： https://blog.csdn.net/neverever01/article/details/108237531

## 1、构造函数和析构函数的作用

构造函数的作用：用于新建对象的初始化工作。
析构函数的作用：用于在撤销对象前，完成一些清理工作，比如：释放内存等。
每当创建对象时，需要添加初始化代码时，则需要定义自己的构造函数；而对象撤销时，需要自己添加清理工作的代码时，则需要定义自己的析构函数。





## 2、类对象作为参数传递的时，用引用

这是C++类对象传递的标准方式



##  3、C++中的重载和重写、覆盖的区别

重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。
重写（overwrite）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。

覆盖（override），用于实现C++中多态：

1. 分别位于父类和子类中；
2. 子类改写父类中的virtual方法；
3. 与父类中的函数原型相同。

————————————————
原文链接：https://blog.csdn.net/neverever01/article/details/108237531



##  4、C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）

#### （34）对象复用的了解，零拷贝的了解？？	



## 5、C++静态绑定和动态绑定

静态：编译时就确认，就是一开始声明为什么类型，后续他的静态类型就一直不变了

动态：通过虚函数实现，具体为当前类指针指向其他类，由于不知道指向哪里，所以他是动态的

https://www.cnblogs.com/lizhenghn/p/3657717.html



## 6、构造函数的三种方式

https://blog.csdn.net/qq_43519886/article/details/105170209

- 默认构造函数。当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。
- 重载构造函数 。参数类型或者个数不一致的时候使用。
- 拷贝构造函数 。 对象复制时使用。

拷贝构造函数（一般情况下，编译器能直接用相同类对象A复制给B，但是只处理非静态）

就是拷贝构造函数没有处理静态数据成员，所以，还是需要自己重写拷贝构造，使得能够处理静态数据成员。



**系统的默认拷贝构造函数是浅拷贝**   

假如该拷贝构造函数里面，申请了一个新的指针，那么对象复制时，该对象也是指向同一段空间，而非新的指针空间。



**拷贝构造函数的深拷贝的写法**

```C++
  Rect(const Rect& r)
  {
  width=r.width;
  height=r.height;
  p=new int(100);  //重新申请新的空间，而不是复用r的空间
  *p=*(r.p);
  }
```



## 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？

https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html

成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下：

```c++
class A{
    int id;
    string name;
    FaceImage face;
    // 成员初始化列表
    A(int& inputID,string& inputName,FaceImage& inputFace):id(inputID),name(inputName),face(inputFace){} 
};

```

因为使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，**省去了一次执行传入参数的默认构造函数的过程**，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些。

另外，有三种情况是必须使用成员初始化列表进行初始化的：

1. 常量成员的初始化，因为常量成员只能初始化不能赋值

2. 引用类型

3. 没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化

   



## 7、友元函数

友元函数用于在类中声明友好关系，在类外定义，然后改函数可以使用类的私有成员和保护成员，但是破坏了类的封装性和数据的隐匿性。

```c++
class A
{
public:
    friend void set_show(int x, A &a);      //该函数是友元函数的声明
private:
    int data;
};

void set_show(int x, A &a)  //友元函数定义，为了访问类A中的成员,如data
{
    a.data = x;
    cout << a.data << endl;
}
```

## 8、友元类

友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。

```c++
class A
{
public:
   friend class C;   //这是友元类的声明，c是A的友好类，c有权限可以访问A，但A还没有权限，除非C中也这样声明
private:
   int data;
};
```

(1) 友元关系**不能被继承**。

(2) 友元关系是**单向的**，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。

(3) **友元关系不具有传递性**。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明
