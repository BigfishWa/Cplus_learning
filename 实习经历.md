## 1、protobuf

Protobuf（Protocol Buffers）是一种**轻量级的数据序列化和通信协议**，由Google开发。它可以用于在不同的系统和编程语言之间高效地进行数据交换和通信。

以下是一些关键的特点和优势：

1. 简单的定义：使用Protobuf，你可以通过编写一个简单的文本文件来定义**数据结构和消息类型**。这个文件使用Protobuf的语法来描述数据的字段、类型和结构。

2. **跨平台和语言**：Protobuf支持多种编程语言，包括C++、Java、Python等，使得不同平台和语言之间的数据交换变得非常方便。

3. 高效的序列化：Protobuf使用**二进制编码**，相比于文本格式如JSON和XML，**它的序列化后的数据更小、更快速，节省了带宽和存储空间。**

4. 可扩展性：Protobuf提供了**强大的扩展机制**，可以在不破坏已有数据的情况下对数据结构进行扩展和更新。

使用Protobuf的基本步骤如下：

1. 定义消息类型：使用Protobuf的语法在一个.proto文件中定义消息类型和字段。

2. 编译.proto文件：使用Protobuf的编译器将.proto文件编译成目标语言的代码。

3. 在应用程序中使用：**在应用程序中引入生成的代码，并使用它来序列化、反序列化和操作消息。**

Protobuf提供了丰富的特性和灵活性，适用于各种场景，例如网络通信、数据存储、配置文件等。你可以访问Google的Protobuf官方网站（[https://developers.google.com/protocol-buffers ↗](https://developers.google.com/protocol-buffers)）获取更详细的文档和教程，以及相关语言的库和工具。



### 1.1 protobuf和json的比较

https://www.cnblogs.com/lianshuiwuyi/p/17626558.html

- Protobuf 是二进制格式，人类无法直接阅读；JSON 是文本格式，人类可以直接阅读和编辑。

- Protobuf 支持静态类型检查，这可以在编译时捕获类型错误。此外，Protobuf 设计了一套版本兼容性机制，可以在不破坏旧版本的情况下添加新的字段。JSON 是动态类型的，无法在编译时捕获类型错误。此外，JSON 没有内置的版本兼容性机制，如果数据结构发生变化，可能需要修改代码以适应新的结构。
- protobuf支持C++、Java、Python、Golang 等，json几乎支持所有语言
- protobuf 的数据结构发生了变化，你需要更新 .proto 文件并重新生成代码。这些步骤都需要额外的时间和工作；json的数据结构发生了变化，你只需要更新你的代码，无需任何其他操作。



**XML的优点:**

1. 格式统一，符合标准；
2. 容易与其他系统进行远程交互，数据共享比较方便。

**XML的缺点:**

1. XML文件庞大，文件格式复杂，传输占带宽；
2. 服务器端和客户端都需要**花费大量代码来解析XML**，导致服务器端和客户端代码变得异常复杂且不易维护；
3. 客户端不同浏览器之间**解析XML的方式不一致**，需要重复编写很多代码；
4. 服务器端和客户端解析XML花费较多的资源和时间。



## 2、conan

原文链接：https://blog.csdn.net/sexyluna/article/details/115428572

1. Conan是C和C ++语言的依赖项和程序包管理器。它是免费和开源的，并且可以在所有平台上使用：Windows，Linux，OSX，FreeBSD，Solaris等，并且可以用于开发所有目标，包括嵌入式，移动（iOS，Android）和裸机。它还与所有构建系统集成，例如CMake，Visual Studio（MSBuild），Makefile，SCons等，包括专有系统。
2. 它是专门为加速C和C ++项目的开发和持续集成而设计和优化的。借助完全的二进制管理，它可以在所有平台上使用完全相同的过程为包的任意数量的不同版本创建和重用任意数量的不同二进制文件（用于不同的配置，如体系结构，编译器版本等）。



Conan是具有客户端-服务器体系结构的分散式软件包管理器。这意味着客户端可以从不同的服务器获取软件包，也可以将软件包上载到不同的服务器（“远程”），类似于“ git”推拉模型到/从git远程服务器。

从较高的角度来看，服务器只是程序包存储。他们不构建也不创建包。这些包是由客户端创建的，并且如果二进制文件是从源代码构建的，则该编译也将由客户端应用程序完成。

- conna是个 c++/c 的包管理工具，基于python开发，开源。
- conan需要编写**conanfile.txt来说明依赖。**
- conan search -r=conan指令可以在远程仓库搜索包
- conan install 指令来根据conanfile.txt安装库文件
- 最终生成文件：conanbuildinfo.cmake
- 再编写cmake后编译工程，将该文件加入到cmake中进行构建
- 完成使用



如果依赖的包源码在本地，那么

- 添加了`exports_source`字段，指示Conan将本地`src`文件夹中的所有文件复制到包配方中。
- 删除了`source()`方法，因为不再需要检索外部源。

Conan 是一个开源的C/C++软件包管理工具，用于管理和构建跨平台的C/C++依赖项。它的主要作用包括：

1. 依赖项管理：Conan 可以帮助你轻松地**管理和跟踪项目所需的各种依赖项**。你可以使用 Conan 在项目中声明和安装依赖项，包括第三方库、工具和其他软件包。

2. 跨平台支持：Conan 允许你在不同的操作系统和平台上管理依赖项，并提供了与各种构建系统（如CMake、Make、Visual Studio等）的集成。这使得你可以在不同环境下共享和重用依赖项，**确保项目在不同平台上的一致性**。

3. 版本控制：Conan 具有强大的版本控制功能，可以**帮助你管理不同的依赖项版本**，并在需要时进行升级或降级。这有助于确保项目的稳定性和兼容性。

4. 构建和部署：Conan 可以与各种构建系统集成，**帮助你自动化构建过程，生成所需的库文件和可执行文件**。它还提供了用于打包和部署依赖项的工具，简化了软件的分发和部署流程。

5. 远程仓库：Conan **支持远程仓库**，允许你从公共或私有的存储库中获取依赖项，并与团队成员共享和协作。这使得依赖项的获取和更新变得更加方便和可控。

总而言之，Conan 简化了 C/C++ 项目的依赖项管理过程，提供了跨平台的支持、版本控制、构建和部署的功能。它的目标是帮助开发者更高效地管理和利用依赖项，提高项目的开发速度和可维护性。

## 3、git

Git 是一种分布式版本控制系统，它用于跟踪和管理软件开发项目的代码变更。通过Git，开发团队可以协作开发、管理代码版本、回滚更改等。

下面是一些常见的Git操作：

1. 初始化仓库：
   - `git init`：在当前目录初始化一个新的Git仓库。

2. 克隆仓库：
   - `git clone <repository>`：克隆一个远程仓库到本地。

3. 工作区与暂存区：
   - `git add <file>`：将文件添加到暂存区，准备提交。
   - `git add .`：将所有修改过的文件添加到暂存区。
   - `git reset <file>`：将文件移出暂存区，恢复到工作区。

4. 提交更改：
   - `git commit -m "<message>"`：将暂存区的文件提交到本地仓库，附带一条说明性提交消息。

5. 分支操作：
   - `git branch`：列出本地分支。
   - `git branch <branch_name>`：创建一个新的分支。
   - `git checkout <branch_name>`：切换到指定分支。
   - `git merge <branch>`：将指定分支的更改合并到当前分支。
   - `git branch -d <branch_name>`：删除指定分支。

6. 远程仓库：
   - `git remote add <name> <url>`：添加一个远程仓库。
   - `git remote -v`：显示远程仓库的详细信息。
   - `git pull <remote> <branch>`：从远程仓库拉取最新的代码。
   - `git push <remote> <branch>`：将本地分支的更改推送到远程仓库。

7. 查看状态和历史：
   - `git status`：显示工作区和暂存区的状态。
   - `git log`：查看提交历史。
   - `git diff`：显示工作区和暂存区文件的差异。

这些是Git的一些基本操作，你可以根据需要进一步学习和探索更多的Git命令和功能。Git提供了强大的版本控制能力，可以帮助开发者更好地管理代码，并与团队成员协作开发。

### 3.1 git rebase

`git rebase` 是 Git 提供的一个强大的命令，用于在分支之间重新应用提交。通过 `git rebase`，可以将一个分支的提交应用到另一个分支上，使提交历史更加整洁和线性。它与 `git merge` 相比，提供了更加清晰的提交历史。

以下是一些常见的 `git rebase` 的用法和操作：

1. 将当前分支的提交应用到目标分支上：
   `````shell
   git checkout target_branch
   git rebase source_branch
   ```
   这将将 `source_branch` 上的提交应用到 `target_branch` 上，并使 `target_branch` 的提交历史线性化。

2. 解决冲突：
   在执行 `git rebase` 过程中，如果发生冲突，Git 将暂停 rebase 过程并标记冲突的文件。打开这些文件，手动解决冲突，然后使用以下命令继续 rebase 进程：
   ````shell
   git add resolved_file
   git rebase --continue
   ```

3. 中止 rebase 进程：
   如果需要中止 rebase 进程，可以使用以下命令：
   ````shell
   git rebase --abort
   ```
   这将恢复到 rebase 之前的状态，放弃所有的 rebase 操作。

4. 修改提交消息：
   在执行 `git rebase` 过程中，可以修改提交消息。当 Git 提示你编辑提交消息时，修改消息并保存文件即可。

5. 修改提交顺序：
   在执行 `git rebase` 过程中，可以重新排列提交的顺序。当 Git 提示你编辑提交消息时，可以通过修改提交的顺序来调整它们的顺序。

6. 强制推送：
   在执行 `git rebase` 后，由于提交历史被改变，可能需要使用强制推送来更新远程分支。使用以下命令进行强制推送：
   ````shell
   git push --force
   ```
   注意：强制推送会改变远程分支的历史，因此在进行强制推送之前，请确保你知道自己在做什么，并与团队成员进行协调。

`git rebase` 可以提供一个干净、线性的提交历史，但在进行 rebase 操作时需要小心，确保你理解其影响并与团队成员进行协调。特别是在与公共分支（如主分支）进行 rebase 操作时，需要谨慎处理以避免潜在的问题。

### 3.2 git 回退版本 git reset

要在 Git 中回退到先前的版本，可以使用 `git reset` 命令。`git reset` 允许你将当前分支的 HEAD 指针移动到指定的提交，并选择性地更新工作区和暂存区。

以下是回退版本的几种常见方法：

1. 回退到上一个提交：
   `````shell
   git reset HEAD^
   ```
   这将将 HEAD 指针移动到上一个提交，并撤销最新的提交。工作区的文件将保持不变。

2. 回退到指定提交：
   ````shell
   git reset <commit>
   ```
   将 `<commit>` 替换为要回退到的提交的哈希值或引用（如分支名）。这将将 HEAD 指针移动到指定提交，并撤销该提交之后的所有提交。工作区的文件将保持不变。

3. 回退并更新工作区：
   ````shell
   git reset --hard <commit>
   ```
   这将将 HEAD 指针移动到指定提交，并重置工作区和暂存区，使其与指定提交完全一致。请注意，此操作将丢失工作区和暂存区中的未提交更改，请确保在执行之前没有重要的未保存更改。

4. 回退并保留更改：
   ````shell
   git reset --soft <commit>
   ```
   这将将 HEAD 指针移动到指定提交，并保留工作区和暂存区的更改。这样你就可以重新提交这些更改，或者进行其他操作。

5. 强制推送回退：
   如果回退的提交已经被推送到远程仓库，并且你希望将回退推送到远程仓库，可以使用强制推送：
   ````shell
   git push --force
   ```
   注意：强制推送会修改远程仓库的历史，请谨慎使用，并确保你知道自己在做什么。

在回退版本之前，请确保备份重要的更改，并与团队成员进行协调，以避免潜在的问题。回退版本是一种改变 Git 仓库历史的操作，应谨慎使用。