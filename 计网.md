## 1、socket网络编程

socket（），bind（），listen（），accept（），send（）和recv（）。
详见：[建立TCP 服务器的系统调用](https://blog.csdn.net/qq_37964547/article/details/81429627)



## 2、UDP如何实现可靠传输（应用层实现）

UDP（User Datagram Protocol）是一种无连接的、不可靠的传输协议，它不提供可靠传输的机制。UDP的设计目标是提供一种简单的、低开销的传输方式，适用于不要求可靠性和顺序性的应用场景。

然而，虽然 UDP 本身不提供可靠传输，但应用程序可以通过**在应用层实现**一些机制来增加 UDP 的可靠性。以下是一些常见的方法：

1. **应答机制**（ACK/NACK）：应用程序可以在数据包的应用层协议中引入应答机制。发送方在发送数据包后等待接收方的应答。如果发送方没有收到应答，可以认为数据包丢失，并进行重传。

1. **数据包序列号**：发送方可以为每个数据包分配一个唯一的序列号。接收方可以根据序列号检测丢失的数据包，并要求发送方进行重传。

1. **超时重传**：发送方在发送数据包后启动一个定时器。如果在规定的时间内没有收到应答，发送方会认为数据包丢失，并进行重传。

1. **前向纠错**（Forward Error Correction）：发送方可以在发送的数据包中添加冗余信息，以便接收方可以纠正部分错误。这样接收方即使收到部分损坏的数据包，仍然可以恢复原始数据。

需要注意的是，通过在应用层实现可靠性机制，会增加额外的开销和复杂性。这些机制可能会导致延迟增加，带宽利用率下降，或者增加处理逻辑的复杂度。因此，在选择 UDP 进行通信时，需要根据应用场景的要求和性能需求来权衡是否需要实现可靠传输机制。对于对传输延迟和带宽利用率要求较高的应用，可能更适合选择使用 TCP 协议来实现可靠传输。

## 3、TCP如何实现可靠传输

TCP（Transmission Control Protocol）是一种面向连接的、可靠的传输协议，它提供了可靠传输的机制。以下是 TCP 实现可靠传输的主要机制：

1. 序列号和确认应答：TCP 使用序列号对发送的数据进行编号，并通过确认应答机制来确保数据的可靠传输。接收方在收到数据后会发送确认应答，指明已经成功接收到数据。发送方在收到确认应答后才会发送下一个数据。**（首部含有序号和确认号，序号就是当前发送数据的第一个字节的编号，确认号（由序号+数据长度+1得到）就是希望下一次收到数据的第一个字节号，确认号发出，说明前面的都已经收到了）**

1. 超时重传：TCP 使用超时重传机制来应对数据包丢失或损坏的情况。发送方在发送数据后**启动一个定时器**（1RTT，每次更新为当前测量的RTT和前面一次的RTT加权计算），如果在规定的时间内没有收到确认应答，发送方会认为数据包丢失，并进行重传。**（冗余确认，比如没有接收到中间某个包，那下一次ack就一直置为丢失包的序号，知道接收到，接收方收到三次冗余ack，就认为丢失了，然后可以执行快重传，就是加法增加拥塞窗口，而不是从1进行慢开始）**

1. 滑动窗口：TCP 使用滑动窗口机制来实现流量控制和拥塞控制。滑动窗口指定了发送方可以连续发送的数据量。接收方通过发送窗口大小来告知发送方自己的接收能力，从而控制发送方的发送速率。

1. 确认丢失的重传：接收方如果没有及时发送确认应答，发送方会认为数据包丢失，并进行重传。接收方收到重复的数据包时会丢弃重复的数据，以确保数据的正确性。

1. 拥塞控制：TCP 通过拥塞控制算法来避免网络拥塞并保持网络的稳定性。拥塞控制算法包括**慢启动、拥塞避免和拥塞检测**等机制，它们根据网络状况动态调整发送方的发送速率。**（拥塞窗口cwnd>门限ssthresh,开始拥塞控制）**

1. 数据校验和：TCP 在每个数据包中添加校验和字段，用于检测数据在传输过程中的错误或损坏。接收方通过校验和来验证数据的完整性，如果发现错误，则要求发送方进行重传。

通过这些机制，TCP 实现了可靠传输的特性。它能够确保数据的完整性、顺序性和不丢失，适用于对可靠性要求较高的应用场景，如文件传输、Web 浏览等。

##  4、 https的具体实现，怎么确保安全性

**SSL是传输层的协议**

具体来说呢就是，服务器在收到客户端请求的时候，给了他一把锁（非对称加密的公钥），然后，客户端自己生成了对称加密（双方都知道如何加密解密），然后用公钥对  对称加密生成的会话密钥 进行加密，传给服务器，这时候，外人想知道会话密钥，就必须要知道私钥（钥匙），而只有服务器知道，服务器一揭开，就知道客户端的密码了，如此加密完成。



**简单来说，就是两个人 都生成了秘钥，不过一个是对称秘钥，一个是非对称秘钥，非对称密钥对 对称秘钥 进行加密。**





## 5、数字证书的了解（高频）

网站就自己的信息给了权威机构CA，然后CA对该信息用私钥加密生成数字证书，数字证书和网站信息都被服务器发给了客户端，客户端一边用网站自己的信息进行解密，一边用权威机构的**公钥解密数字证书**，一对比，就知道网站是不是真的了。



**公钥验证数字签名的过程如下：**

1. 数据和数字签名获取：接收方从发送方处获取数据和相应的数字签名。数字签名是使用发送方的私钥对数据进行加密生成的。
2. 使用公钥解密数字签名：接收方使用发送方的**公钥对数字签名进行解密**。这个过程会还原出数字签名的哈希值。
3. 计算数据的哈希值：接收方**对接收到的数据使用相同的哈希算法**，计算出数据的哈希值。
4. 比较哈希值：接收方**比较**解密得到的数字签名哈希值与自己计算的数据哈希值。如果两个哈希值匹配，说明数字签名是有效的。

如果数字签名的哈希值与接收方计算的数据哈希值一致，就意味着数据的完整性未被篡改，并且数字签名确实是由发送方的私钥生成的。这样，接收方可以确认数据的来源和完整性，并相信数据是由发送方发送的。

## 6、MD5算法原理

MD5算法在过去广泛应用于数据完整性校验、密码存储和数据摘要等领域。



MD5（Message Digest Algorithm 5）是一种常见的哈希函数算法，**用于将任意长度的数据转换为固定长度的哈希值**（通常为128位）。下面是MD5算法的基本原理：

1. 填充数据：将输入的数据按照一定规则进行填充，使其长度满足一定要求。填充通常包括添加一个位为1的比特，然后添加一系列位为0的比特，以保证数据长度能够被512位整除（MD5的分组大小为512位）。

1. 初始化缓冲区：定义一个128位的缓冲区，用于存储中间结果和最终的哈希值。

1. 分组处理：将填充后的数据划分为若干个512位的分组。对每个分组执行以下操作：

   - 初始化：将缓冲区中的初始值加载到相应的变量中。

   - 处理分组：对分组进行一系列的循环操作，包括置换、置换函数和循环左移等操作。这些操作将逐步更新缓冲区的值。

   - 更新缓冲区：将处理后的分组与缓冲区的值进行运算，更新缓冲区的值。

1. 输出结果：将最终的缓冲区值转换为十六进制表示的哈希值，即为MD5算法的输出结果。

**MD5算法的核心思想是通过一系列复杂的位操作和置换函数，将输入数据转换为唯一的128位哈希值。由于哈希值的长度固定且相对较短，因此MD5算法不可逆，即无法从哈希值还原出原始数据。**此外，MD5算法也存在一些安全性问题，如碰撞攻击等，因此在一些安全性要求较高的场景中，推荐使用更强大的哈希算法，如SHA-256等。



不可逆在于：通过一系列复杂的位操作和置换函数。因为MD5在进行消息摘要的过程中，数据与原始数据相比**发生了丢失**。





## 7、ping功能原理（ICMP）

ping是使用ICMP协议来进行工作的。 **ICMP:网络控制报文协议**，工作在ip层

- 首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。
- 然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。
- 然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。

目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。


**ICMP五种类型**

1、终点不可达，ping

2、源点抑制，拥塞导致数据包丢弃

3、时间超时

4、参数问题，首部字段有问题

5、路由重定向

## 8、TCP/IP的粘包

TCP/IP的粘包（Packet Sticking）是指在TCP传输过程中，**发送方将多个较小的数据包打包成一个较大的数据包发送**，而接收方在接收数据时可能**无法准确划分出原始的数据包边界**，导致多个数据包被粘合在一起形成一个大的数据块。

粘包问题是由TCP协议的特性引起的。**TCP是一种面向流的协议，它使用字节流进行数据传输，没有数据包的概念**，而是根据字节流进行数据的分割和重组。在发送端，应用程序将数据分割为合适的大小，然后通过TCP协议发送。而在接收端，TCP协议将接收到的数据重新组装为完整的数据流，并交给应用程序处理。

由于TCP协议的数据传输是基于字节流的，而不是基于数据包的，因此在传输过程中，发送方和接收方的数据包划分可能不一致，导致粘包现象的出现。常见的导致粘包的原因有：

1. 发送方连续发送数据：发送方在短时间内连续发送多个小数据包，TCP协议为了提高传输效率，可能会将这些数据包打包成一个较大的数据块发送，导致接收方无法准确划分出原始的数据包边界。

1. 接收方缓冲区不及时接收：如果接收方的应用程序没有及时读取接收缓冲区中的数据，**TCP协议会将多个数据包缓存起来，导致多个数据包被粘合在一起。**

1. 网络传输延迟或拥塞：网络中的延迟或拥塞会导致TCP协议的传输过程中发生重传、拥塞控制等机制，这可能导致**数据包在传输过程中被合并或拆分，从而引发粘包问题。**

粘包问题可能会导致接收方解析数据出错，无法准确还原发送方发送的数据包。



**为了解决粘包问题，可以采取以下措施：**

1. 明确数据包边界：在数据包中包含特定的分隔符或长度字段，接收方根据这些边界信息来划分数据包。

1. 添加头部信息：在每个数据包的头部添加长度字段，接收方根据长度字段来准确划分数据包。

1. 使用定长数据包：将每个数据包固定为相同的长度，无论数据内容是否填满，接收方都可以准确划分数据包。

1. 使用应用层协议处理粘包：应用层协议可以在传输层的TCP之上进行进一步的封装，例如在数据包中使用特定的分隔符或长度字段，以便接收方能够准确还原数据包。优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等。

通过采取适当的策略和技术手段，可以有效地解决TCP/IP粘包问题，确保数据的准确传输和解析。



## 9、DNS的工作过程和原理

迭代查询：本地域名服务器 自己去一个个找，上级不行，他告诉你去找上上级，找上上级……，最后直接得到结果

递归查询：本地域名服务器提交给上级，上级给上上级，最后一级一级传下来



1、递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。
2、迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果

## 10、网络7层协议，及协议簇

![TCP-IP五层协议](picture\TCP-IP五层协议.jpg)