# c++内存区域的划分

## 1、内存区域划分

   一个由C/C++编译的程序占用的内存分为以下几个部分：

- **栈区（Stack）**：由编译器（Compiler）自动分配释放，存放函数的参数值，局部变的值等。其操作方式类似于数据结构中的栈。
- **堆区（Heap ）**：一般由程序员分配释放，若程序员不释放，程序结束时由操作系统回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
- **全局区（静态区）（static）**：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。
- **文字常量区**：常量字符串就是放在这里的。程序结束后由系统释放。
- **程序代码区**：存放函数体的二进制代码。





## 2、堆和栈的区别

- 从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。

- 堆空间因为会有频繁的分配释放操作，会产生**内存碎片**；
- 堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小；



## 3、堆快一点还是栈快一点？（字节提前批一面）

栈快一点。因为**操作系统会在底层**对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且**有专门的指令执行**，所以栈的效率比较高也比较快。

而堆的操作是由C/C++**函数库**提供的，在分配堆内存的时候需要一定的算法**寻找合适大小的内存**。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。



## 4、内存对齐

https://zhuanlan.zhihu.com/p/622252108

结构体内存对齐方式：以结构体内变量的最大长度为倍数，进行存储。

通俗的说：保证变量不跨两个字长，使其一次性读取。而不是一个字节在上一个字长，另外三个字节在下一个字长，这样贼麻烦。

书面语：如果其首地址在字长的整数倍处，CPU只需要读内存一次；如果其首地址不在字长整数倍处，CPU则需要读地址两次，影响程序性能。



## 5、内存泄露

https://www.cnblogs.com/qkqBeer/articles/11154898.html

没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露。

即删除父类指针时，父类指针只调用了自己的析构函数，而没有调用子类对象的析构函数，因为他不是虚函数，所以无法调用，造成子类内存没有被释放，所以泄露。



**另外还有就是 new/delete ，malloc/free 等配套使用，还有释放对象数组时要使用  delete[]  而不是delete。**



避免方法：

1. malloc/free要配套
2. **使用智能指针**：可以自行进行释放，避免忘记释放指针指向的内存地址造成内存泄漏。
3. 将基类的析构函数设为虚函数；



## 6、内存回收

**被free回收的内存是立即返还给操作系统吗？为什么**
https://blog.csdn.net/YMY_mine/article/details/81180168

不是的，被free回收的内存会首先**被ptmalloc使用双链表保存起来**。

当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就**避免了频繁的系统调用**，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。



## 7、为什么C++没有垃圾回收机制？

C++没有内置的垃圾回收（Garbage Collection）机制，主要有以下几个原因：

1. 性能：C++ 是一种系统级编程语言，强调对计算机硬件的直接控制和高性能。垃圾回收需要对内存进行扫描和管理，这可能导致运行时的开销和额外的内存占用，这对于一些性能敏感的应用来说是不可接受的。**C++ 的设计目标之一是提供低级别的内存管理**，以便开发人员可以更好地控制内存的分配和释放，以满足对性能的要求。

1. 可预测性：C++ 是一种静态类型语言，**强调程序员对内存的显式控制**。显式地管理内存分配和释放可以让开发人员更好地掌握程序的行为，使得内存使用的开销和生命周期更加可预测。垃圾回收机制会引入不确定性，因为程序员无法精确控制对象的销毁时机，可能导致资源泄漏或在不适当的时间释放对象。

1. 对象生命周期控制：C++ **支持对象的精确生命周期控制**，通过构造函数和析构函数可以在对象创建和销毁的时候执行特定的逻辑。这种精确控制对于一些资源管理（如文件句柄、数据库连接等）非常重要，而垃圾回收机制往往难以提供这种精确的生命周期管理。

尽管 C++ 标准库没有提供内置的垃圾回收机制，但是可以使用**智能指针**（如 `std::shared_ptr`、`std::unique_ptr`）和 **RAII**（Resource Acquisition Is Initialization）等技术来辅助进行内存管理。这些技术可以帮助开发人员在不显式调用 `delete` 的情况下，自动释放对象所占用的内存，减少手动内存管理的负担。

需要注意的是，现代的 C++ 扩展了语言的功能，提供了一些第三方垃圾回收库，例如 `libgc`、`Boehm GC` 等，可以在特定场景下使用。但这些库并非 C++ 标准的一部分，开发人员需要显式地选择并使用它们。

## 8、RAII是如何管理内存的？

RAII（Resource Acquisition Is Initialization）是C++中一种重要的编程技术，用于管理资源的获取和释放。它基于对象的生命周期和析构函数的调用，**在对象的构造函数中获取资源，在析构函数中释放资源，从而确保资源的正确管理**。

在内存管理方面，RAII 可以通过智能指针来实现。C++标准库提供了两种主要的智能指针：`std::shared_ptr` 和 `std::unique_ptr`。

1. `std::shared_ptr`：它实现了共享所有权的智能指针。多个 `std::shared_ptr` 可以指向同一个对象，并且会跟踪对象的引用计数。只有当所有 `std::shared_ptr` 都释放了对对象的引用时，对象才会被销毁。这样可以确保在不再需要对象时，它的内存会被正确释放。

1. `std::unique_ptr`：它实现了独占所有权的智能指针。每个 `std::unique_ptr` 只能指向一个对象，并且在其所属的作用域结束时自动调用析构函数释放对象的内存。`std::unique_ptr` 不能被复制，**但可以通过移动语义进行所有权的转移**。

使用智能指针时，可以通过以下步骤进行内存管理：

1. 在需要动态分配内存的地方，使用智能指针进行资源的获取。例如，可以使用 `std::make_shared` 或 `std::make_unique` 函数创建智能指针对象，并传递所需的参数。

1. 在对象不再需要时，智能指针的作用域结束，或者手动将其设置为 `nullptr`，智能指针的析构函数会被调用，自动释放对象所占用的内存。

通过使用智能指针和 RAII 技术，**可以避免手动管理动态分配的内存，减少内存泄漏和悬挂指针（dangling pointer）等错误**。智能指针会在对象不再需要时自动释放资源，提供了更安全和便利的内存管理方式。
