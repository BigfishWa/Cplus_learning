## 1、Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关

在理论上，Linux的进程数量是没有明确限制的。这是因为Linux内核使用**进程标识符（PID**）来唯一标识每个进程，而PID是一个**32位的无符号整数**，因此理论上可以创建的进程数量为2^32，即大约42亿个进程。

然而，实际上，系统资源和性能限制会限制可创建的进程数量。每个进程都需要占用一定的内存和其他系统资源，如**文件描述符、栈空间等。当系统资源达到上限时，无法再创建更多的进程。**

另外，一个进程可以创建多个线程。**线程**是进程内的执行单元，**共享进程的内存空间和其他资源**。线程的数量与进程的能力和资源限制有关。具体来说，以下因素可能影响一个进程可以创建的线程数量：

1. 系统资源限制：系统的总内存、**CPU核心数**、文件描述符等资源限制可以影响一个进程可以创建的线程数量。

2. 线程栈空间：**每个线程都需要一定的栈空间来保存局部变量、函数调用信息**等。较大的线程栈空间将占用更多的内存，限制了可创建的线程数量。

3. 线程调度开销：操作系统对线程的调度和管理需要一定的开销。较多的线程数量可能增加调度开销，影响系统性能。

4. 应用程序设计：应用程序的设计和需求也会影响线程的数量。合理的线程使用和管理可以提高系统的并发性能。

总之，一个进程可以创建的线程数量受到系统资源限制、线程栈空间、线程调度开销和应用程序设计等因素的影响。在实际应用中，需要根据系统资源和性能要求合理地管理进程和线程的数量。



## 2、进程间的通信方式

1、共享存储，共享一段存储空间

2、消息传递，采用格式化的消息，用发送消息和接收消息进行交换，有消息队列

3、管道通信，设立缓冲区，每次只能写满，然后读空，半双工通信；如果要全双工，设立两个缓冲区即可。

4、信号量（p、v操作），

实现同步时，p等待资源，让另一个进程生成所需资源，v释放信号**（A p操作，B V 操作）**

实现互斥时，当前进程，先p，当前执行后，再由当前进行进行v **（A pV操作，B PV 操作）**

5、**套接字**：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于**不同设备之间**的进程通信。

### 2.1 进程同步

1、信号量

2、管程

管程可以被看作是一个抽象类，他可以管理共享数据，并含有相关操作，因为每次**只允许一个进行在管程内执行某个内部过程**，可以实现同步。 

另外，**管程的互斥访问完全由编译程序在编译时自动添加，无需程序员关注**。



### 2.2  线程间的通信方式

- 使用全局变量
- 使用信号机制
- 使用事件

在线程间进行通信是多线程编程中的重要问题，常见的线程间通信方式包括以下几种：（来源chatGPT）

1. 共享内存（Shared Memory）：
   - 多个线程共享同一块内存区域，可以通过读写共享内存来进行通信。
   - 需要使用互斥量、信号量等同步机制来保证对共享内存的互斥访问。

2. 互斥量（Mutex）：
   - 使用互斥量可以实现线程之间的互斥访问共享资源。
   - 通过加锁和解锁互斥量来控制对共享资源的访问。

3. 条件变量（Condition Variable）：
   - 条件变量用于线程间的条件通知和等待。
   - 一个线程可以通过条件变量等待某个条件满足，而另一个线程可以通过条件变量发出条件满足的信号。

4. 信号量（Semaphore）：
   - 信号量用于控制对共享资源的并发访问。
   - 通过信号量的加减操作来进行线程间的同步和互斥。

5. 管道（Pipe）：
   - 管道是一种半双工的通信方式，用于在两个线程之间传递数据。
   - 一个线程将数据写入管道的写端，另一个线程从管道的读端读取数据。

6. 消息队列（Message Queue）：
   - 消息队列是一种在多个线程之间传递消息的通信方式。
   - 一个线程将消息发送到消息队列，而另一个线程从消息队列中接收消息。

7. 事件（Event）：
   - 事件是一种线程间的同步机制，用于线程之间的通知和等待。
   - 一个线程可以等待事件的触发，而另一个线程可以触发事件。
   - 事件通常有两种状态：已触发（signaled）和未触发（等待事件和重置事件）（nonsignaled）。

这些线程间通信方式都有各自的适用场景和特点，开发者可以根据实际需求选择合适的通信方式。在实际应用中，常常需要结合多种通信方式来实现复杂的线程间交互和同步操作。注意，在使用多线程编程时，需要注意线程安全性和同步机制的正确使用，以避免数据竞争和死锁等问题。

### 2.3 互斥量和信号量的区别

互斥量（Mutex）和信号量（Semaphore）是两种常用的线程同步机制，它们在功能和使用上有一些区别。

两者可以配合使用，比如互斥量保证拿到（P操作）了左筷子和右筷子（中间不允许被打断），然后吃完饭，在用V操作释放资源。

1. 功能：
   - 互斥量：用于保护共享资源的**互斥访问**，即**一次只允许一个线程访问被互斥量保护的资源**。互斥量提供了独占的访问权限，防止多个线程同时修改共享数据。
   - 信号量：用于控制对共享资源的**并发访问**数量。**信号量维护一个计数器，多个线程可以通过对信号量的等待和释放操作来实现对共享资源的控制。**

2. 计数：
   - 互斥量：只有两个状态，被锁定（locked）和未锁定（unlocked）。互斥量只能保护一个线程同时访问共享资源。
   - 信号量：具有一个计数器，可以表示同时允许的线程数量。计数器的初值可以大于1，表示允许多个线程同时访问共享资源。

3. 使用方式：
   - 互斥量：通过加锁和解锁操作来控制对共享资源的访问。线程在访问共享资源之前需要获取互斥量的锁，访问完成后释放锁以供其他线程使用。
   - 信号量：通过等待和释放操作来控制对共享资源的访问。线程在访问共享资源之前需要等待信号量，如果信号量的计数器大于0，线程可以继续访问，访问完成后释放信号量，计数器加1。

4. 应用场景：
   - 互斥量：适用于保护共享资源的互斥访问，例如对共享数据的读写操作的互斥保护。
   - 信号量：适用于控制对共享资源的并发访问数量，例如**线程池中限制并发任务的数量**。

需要注意的是，互斥量和信号量都是用于线程同步的工具，但在使用时需要遵循正确的同步机制和使用约定，以避免数据竞争、死锁等问题。选择合适的同步机制取决于具体的应用场景和需求。

## 3、系统调用有哪些

系统调用是操作系统提供给应用程序的接口，用于访问操作系统的功能和服务。常见的系统调用包括但不限于以下几种：

1. 文件操作：
   - 打开文件（open）
   - 关闭文件（close）
   - 读取文件（read）
   - 写入文件（write）
   - 定位文件指针（lseek）
   - 创建文件（creat）
   - 删除文件（unlink）

2. 进程控制：
   - 创建新进程（fork）
   - 执行新程序（exec）
   - 终止进程（exit）
   - 等待子进程结束（wait、waitpid）
   - 获取当前进程ID（getpid）
   - 获取父进程ID（getppid）
   - 进程间通信（pipe、socket）

3. 内存管理：
   - 分配内存（malloc、brk）
   - 释放内存（free）
   - 修改内存保护（mprotect）
   - 获取系统页大小（getpagesize）

4. 文件系统操作：
   - 创建目录（mkdir）
   - 删除目录（rmdir）
   - 列出目录内容（readdir）
   - 修改文件权限（chmod）
   - 修改文件所有者（chown）

5. 网络和套接字：
   - 创建套接字（socket）
   - 绑定套接字（bind）
   - 监听套接字（listen）
   - 接受连接（accept）
   - 发起连接（connect）
   - 发送数据（send）
   - 接收数据（recv）

6. 时间和日期：
   - 获取当前时间（time）
   - 获取日期和时间（gettimeofday）
   - 格式化日期和时间（strftime）

这只是一小部分常见的系统调用示例，实际上每个操作系统都有自己特定的系统调用接口和功能。在不同的操作系统和编程语言中，系统调用的名称和参数可能会有所不同。开发者可以通过操作系统提供的系统调用接口来访问更底层的操作系统功能，实现对硬件和系统资源的控制和管理。

## 4、用户态切换到内核态（通过系统调用实现）

这种切换是通过**系统调用（system call）来实现的**，以下是用户态切换到内核态的一般**流程**：

1. 应用程序执行到系统调用指令：应用程序在需要进行特权操作时，通过执行特定的系统调用指令（例如x86架构中的int 0x80或sysenter指令）触发切换到内核态。
2. 内核态堆栈切换：当应用程序执行系统调用指令时，处理器会切换到内核态，并将当前的程序状态保存在内核态堆栈中，包括程序计数器、寄存器状态、堆栈指针等。
3. 内核态执行系统调用服务例程：一旦进入内核态，控制权将传递给操作系统的内核代码，即系统调用服务例程。该例程负责执行特定的内核功能，并提供所需的服务。
4. 内核态返回结果：在系统调用服务例程执行完毕后，将结果返回给应用程序。结果可能包括请求的操作结果、错误码等。
5. 返回到用户态：一旦系统调用服务例程执行完毕并返回结果，处理器将恢复用户态的堆栈和寄存器状态，并将控制权返回给应用程序，应用程序可以继续在用户态执行



## 5、操作系统的内存管理

https://www.cnblogs.com/peterYong/p/6556619.html

https://zhuanlan.zhihu.com/p/141602175

操作系统的内存管理包括物理内存管理和虚拟内存管理

- 物理内存管理包括  交换与覆盖，分页管理，分段管理和段页式管理等；
- 虚拟内存管理包括  虚拟内存的概念，页面置换算法，页面分配策略等；

交换：不同作业之间，把内存换入和换出

覆盖：同个进程之间，不是每时每刻都要用到全部的东西，所以当前没用到的要被当前需要用到的覆盖



### 5.1 分页管理

从计算机角度提出

页大小和内存中的块大小一样，逻辑页地址到物理内存地址，通过在**内存中存放的页表**查询得到的，最后加上页内偏移就是实际的物理地址。（页表含有页和块号的对应关系），当页太多时，**考虑多级页表**，加快查询速度。

由于页表存放灾厄内存中，所以需要**两次访问内存**，还有一次是拿到地址取数据。

由此，衍生快慢表，将快表存放在高速缓冲寄存器（TLB）中，就少了一次访存。



### 5.2 分段管理

从用户角度提出    将程序切分为多个段。故而一个进程只有一个段表，但是可以有多个页表。

逻辑段到物理内存的映射，含有字段：<段号，段长，本段在内存中的起始地址>，注意**段长不固定**



### 5.3 段页式管理

程序分段，段内采用分页管理

具体为：通过段号，在段表寄存器中找到段表起始地址和段长度，然后根据段表找到页表起始地址，再根据页表找到块号，最后加上偏移量得到物理地址。

**需要三次访存**，段表、页表、取数，三次。同样可以使用快表，减少一次访存。



### 5.4 虚拟内存

高速缓存技术。

虚拟内存得益于局部性原理，就是说程序具有时间局部性和空间局部性。就是空间相邻，下一次访问的还是这个空间附近的；就是下一时间还是访问的当前指令。

简单来说，就是不用一次性全部装入内存，而是可以换进换出，这就使得内存好像看起来增加了。

1、请求分页存储管理，缺页中断，寻找顺序，快表->内存->外存（换页）

2、请求分段存储管理

3、请求段页式管理



### 5.5 页面置换算法

1、最佳置换算法（OPT）： 以后都不用的换出，无法实现

2、先进先出页面置换算法： 会出现Belady异常，页故障不减反增

3、最近最久未使用算法（LRU）： 将最近一段时间内（堆栈实现，一直往前找，找到为止），没有访问的页置换出去

4、Clock置换算法： 改进的算法考虑当前页的访问和修改情况，把最差的情况的页换出去

clock别名最近未用算法（NRU）



## 6、死锁

必要条件：

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 占有并请求：一个进程因请求资源而阻塞时，对**已获得的资源保持不放**。

（3） 不可剥夺:进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待:若干进程之间形成一种头尾相接的循环等待资源关系

**产生死锁的原因**主要是：

（1） 因为系统资源不足。

（2） 进程运行**推进的顺序不合适**。

（3） 资源分配不当等。



死锁处理策略：

1）预防死锁（破坏必要条件） 

2）避免死锁（银行家算法） 

3）死锁的检测（资源分配图）

4）死锁解除 ，资源剥夺法、撤销进程法（逐步撤销，优先级撤销）、进程回退法（系统开销比较大，要记录以前的东西）



## 7、实现一个mutex互斥锁（Test and Set 原子操作）

一个Test-and-Set(TAS)指令包括两个子步骤，**把给定的内存地址设置为1，然后返回之前的旧值。**
这两个子步骤在硬件上实现为一个**原子操作**，执行期间不会被其他处理器打断。

```c++
static int flag=0;

void lock(){
  while(TestAndSet(&flag,1)==1); //flag=1表明该锁已经锁住
}
void unlock(){
  flag=0;
}
//因为while有可能被重入，所以可以用TestandSet()方法。

int TestAndSet(int *ptr, int new) {
    int old = *ptr;
    *ptr = new; //这里已经把flag=1完成了
    return old;
}
————————————————
https://blog.csdn.net/kid551/article/details/84338619
```

## 8、大端存储和小端存储

大端字节序，符合写作习惯，如0x 0102   01共计占用一个字节，写的时候是在最左边，而最左边一般是低位存储地址，存放的却是数据的高位

小端存储符合计算方式，从低地址，计算的是数据的低位部分。

判断大小端的方法：使用一个union数据结构，所有成员公用一块内存，所以访问的时候，可以通过char来逐字节访问。



```c++
union{
  short s;
  char c[2]; // sizeof(short)=2;
}un;
un.s=0x0102;
if(un.c[0]==1 and un.c[1]==2) cout<<"大端"; 
if(un.c[0]==2 and un.c[1]==1) cout<<"小端";
```

